
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "generated/autoexamples/02-synth-data.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_generated_autoexamples_02-synth-data.py>`
        to download the full example code. or to run this example in your browser via Binder

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_generated_autoexamples_02-synth-data.py:


=========================
Synthetic Data Generation
=========================

This example shows how to use TorchSim to generate synthetic data.

We will use torchio and sigpy to get realistic ground truth maps and
coil sensitivities. These can be installed as:
    
``pip install torchio``
``pip install sigpy``

.. GENERATED FROM PYTHON SOURCE LINES 17-21

.. colab-link::
   :needs_gpu: 0

   !pip install torchsim torchio sigpy

.. GENERATED FROM PYTHON SOURCE LINES 23-26

We will use realistic maps from the IXI dataset,
downloaded using ``torchio``:


.. GENERATED FROM PYTHON SOURCE LINES 27-44

.. code-block:: Python

    import warnings

    warnings.filterwarnings("ignore")

    import os
    import torchio as tio

    path = os.path.realpath("data")
    ixi_dataset = tio.datasets.IXI(
        path,
        modalities=("PD", "T2"),
        download=False,
    )

    # get subject 0
    sample_subject = ixi_dataset[0]








.. GENERATED FROM PYTHON SOURCE LINES 45-49

We will now extract an example slice
and compute M0 and T2 maps to be used
as simulation inputs.


.. GENERATED FROM PYTHON SOURCE LINES 50-55

.. code-block:: Python

    import numpy as np

    M0 = sample_subject.PD.numpy().astype(np.float32).squeeze()[:, :, 60].T
    T2w = sample_subject.T2.numpy().astype(np.float32).squeeze()[:, :, 60].T








.. GENERATED FROM PYTHON SOURCE LINES 56-57

Compute T2 map:

.. GENERATED FROM PYTHON SOURCE LINES 58-68

.. code-block:: Python

    sa = np.sin(np.deg2rad(8.0))
    ta = np.tan(np.deg2rad(8.0))

    T2 = -92.0 / np.log(T2w / M0)
    T2 = np.nan_to_num(T2, neginf=0.0, posinf=0.0)
    T2 = np.clip(T2, a_min=0.0, a_max=np.inf)

    M0 = np.flip(M0)
    T2 = np.flip(T2)








.. GENERATED FROM PYTHON SOURCE LINES 69-73

Now, we can create our simulation function

Let's use torchsim fse simulator


.. GENERATED FROM PYTHON SOURCE LINES 74-87

.. code-block:: Python

    import torchsim


    def simulate(T2, flip, ESP, device="cpu"):
        # get ishape
        ishape = T2.shape
        output = torchsim.fse_sim(
            flip=flip, ESP=ESP, T1=1000.0, T2=T2.flatten(), device=device
        )

        return output.T.reshape(-1, *ishape).numpy(force=True)









.. GENERATED FROM PYTHON SOURCE LINES 88-90

Assume a constant refocusing train


.. GENERATED FROM PYTHON SOURCE LINES 91-105

.. code-block:: Python

    flip = 180.0 * np.ones(32, dtype=np.float32)
    ESP = 5.0
    device = "cpu"

    # simulate acquisition
    echo_series = M0 * simulate(T2, flip, ESP, device=device)

    # display
    img = np.concatenate((echo_series[0], echo_series[16], echo_series[-1]), axis=1)

    import matplotlib.pyplot as plt

    plt.imshow(abs(img), cmap="gray"), plt.axis("image"), plt.axis("off")




.. image-sg:: /generated/autoexamples/images/sphx_glr_02-synth-data_001.png
   :alt: 02 synth data
   :srcset: /generated/autoexamples/images/sphx_glr_02-synth-data_001.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    (<matplotlib.image.AxesImage object at 0x7f0c11ed28c0>, (-0.5, 767.5, 255.5, -0.5), (-0.5, 767.5, 255.5, -0.5))



.. GENERATED FROM PYTHON SOURCE LINES 106-108

Now, we want to add coil sensitivities. We will use Sigpy:


.. GENERATED FROM PYTHON SOURCE LINES 109-113

.. code-block:: Python

    import sigpy.mri as smri

    smaps = smri.birdcage_maps((8, *echo_series.shape[1:]))








.. GENERATED FROM PYTHON SOURCE LINES 114-116

We can simulate effects of coil by simple multiplication:


.. GENERATED FROM PYTHON SOURCE LINES 117-120

.. code-block:: Python

    echo_series = smaps[:, None, ...] * echo_series
    print(echo_series.shape)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    (8, 32, 256, 256)




.. GENERATED FROM PYTHON SOURCE LINES 121-124

Now, we want to simulate k-space encoding. We will use a simple Poisson Cartesian encoding
from Sigpy.


.. GENERATED FROM PYTHON SOURCE LINES 125-132

.. code-block:: Python

    import sigpy as sp

    mask = np.stack([smri.poisson(T2.shape, 32) for n in range(32)], axis=0)
    ksp = mask * sp.fft(echo_series, axes=range(-2, 0))

    plt.imshow(abs(ksp[0, 0]), vmax=50), plt.axis("image"), plt.axis("off"), plt.colorbar()




.. image-sg:: /generated/autoexamples/images/sphx_glr_02-synth-data_002.png
   :alt: 02 synth data
   :srcset: /generated/autoexamples/images/sphx_glr_02-synth-data_002.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    (<matplotlib.image.AxesImage object at 0x7f0c08aca020>, (-0.5, 255.5, 255.5, -0.5), (-0.5, 255.5, 255.5, -0.5), <matplotlib.colorbar.Colorbar object at 0x7f0c08587b50>)



.. GENERATED FROM PYTHON SOURCE LINES 133-137

Potentially, we could use Non-Cartesian sampling and include non-idealities
such as B0 accrual and T2* decay during readout using ``mri-nufft``.

Now, we can wrap it up:

.. GENERATED FROM PYTHON SOURCE LINES 138-150

.. code-block:: Python



    def generate_synth_data(M0, T2, flip, ESP, phases=None, ncoils=8, device="cpu"):
        echo_series = M0 * simulate(T2, flip, ESP, device=device)
        smaps = smri.birdcage_maps((ncoils, *echo_series.shape[1:]))
        echo_series = smaps[:, None, ...] * echo_series
        mask = np.stack(
            [smri.poisson(T2.shape, len(flip)) for n in range(len(flip))], axis=0
        )
        return mask * sp.fft(echo_series, axes=range(-2, 0))









.. GENERATED FROM PYTHON SOURCE LINES 151-153

Reconstruction shows the effect of undersampling:


.. GENERATED FROM PYTHON SOURCE LINES 154-160

.. code-block:: Python

    ksp = generate_synth_data(M0, T2, flip, ESP, device=device)
    recon = sp.ifft(ksp, axes=range(-2, 0))
    recon = (recon**2).sum(axis=0) ** 0.5
    img = np.concatenate((recon[0], recon[16], recon[-1]), axis=1)
    plt.imshow(abs(img), cmap="gray"), plt.axis("image"), plt.axis("off")




.. image-sg:: /generated/autoexamples/images/sphx_glr_02-synth-data_003.png
   :alt: 02 synth data
   :srcset: /generated/autoexamples/images/sphx_glr_02-synth-data_003.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    (<matplotlib.image.AxesImage object at 0x7f0c08446590>, (-0.5, 767.5, 255.5, -0.5), (-0.5, 767.5, 255.5, -0.5))



.. GENERATED FROM PYTHON SOURCE LINES 161-163

This can be combined with data augmentation in torchio to generate synthetic
datasets, such as in Synth-MOLED.


.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (0 minutes 12.372 seconds)


.. _sphx_glr_download_generated_autoexamples_02-synth-data.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: binder-badge

      .. image:: images/binder_badge_logo.svg
        :target: https://mybinder.org/v2/gh/infn-mri/torchsim/gh-pages?urlpath=lab/tree/examples/generated/autoexamples/02-synth-data.ipynb
        :alt: Launch binder
        :width: 150 px

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: 02-synth-data.ipynb <02-synth-data.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: 02-synth-data.py <02-synth-data.py>`

    .. container:: sphx-glr-download sphx-glr-download-zip

      :download:`Download zipped: 02-synth-data.zip <02-synth-data.zip>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
